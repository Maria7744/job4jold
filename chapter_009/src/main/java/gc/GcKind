1.-XX:+UseSerialGC-
Serial GC (он же последовательный сборщик)
Основное достоинство данного сборщика очевидно —
это непритязательность по части ресурсов компьютера. Так как всю работу он выполняет
последовательно в одном потоке, никаких заметных оверхедов и негативных побочных эффектов у
него нет.

ЧерепахаГлавный недостаток тоже понятен — это долгие паузы на
сборку мусора при заметных объемах данных. Кроме того, видно, что все настройки Serial GC
крутятся вокруг размеров различных регионов кучи. То есть для тонкой настройки требуется
самому что-то изучать, настраивать, экспериментировать и прочее. Кому-то это может прийтись не по душе.

Если вашему приложению не требуется большой размер кучи для работы (Oracle указывает условную
границу 100 МБ), оно не очень чувствительно к коротким
 остановкам и ему для работы доступно только одно ядро процессора, то можно приглядеться к
 этому варианту. В противном случае можно поискать вариант по-лучше.

Существуют опции -XX:MinHeapFreeRatio=? и -XX:MaxHeapFreeRatio=?, которые задают минимальную и
 максимальную долю свободного места в каждом поколении, при достижении которой размер поколения будет
 автоматически увеличен или уменьшен соответственно. Например, если MinHeapFreeRatio=35, то при падении
 доли свободного места в каком-либо поколении ниже 35%, этому поколению будет предоставлено дополнительное место, чтобы не менее 35% стало свободным. Аналогично, если MaxHeapFreeRatio=65, то при увеличении доли свободного места в поколении до 65% и более, часть выделенной этому поколению памяти будет освобождена для возвращения к желаемому порогу. Значения данных параметров по умолчанию зависят от аппаратных характеристик компьютера.

Установить желаемое отношение размера старшего поколения к суммарному размеру регионов
младшего поколения можно с помощью опции -XX:NewRatio=?. Например, NewRatio=3 означает,
что для младшего поколения (Eden + S0 + S1) будет отведена четверть кучи, а для старшего —
 три четверти. Контринтуитивное название этой опции вносит некоторую путаницу даже в документацию
  Oracle, но работает она именно так. Тут проще запомнить, что там, где названия опций заканчиваются на Ratio, реальная величина будет обратной той, что вы указали.

При желании можно ограничить размер младшего поколения абсолютными величинами снизу и сверху
 с помощью опций -XX:NewSize=? и -XX:MaxNewSize=?. Если вы хотите установить для NewSize и MaxNewSize одинаковые значения, то можно просто использовать опцию -Xmn. Например, -Xmn256m эквивалентно -XX:NewSize=256m -XX:MaxNewSize=256m.

Можно еще залезть внутрь младшего поколения и настроить отношение размера Eden к размерам Survivor.
Это делается с помощью опции -XX:SurvivorRatio=?. Например, при SurvivorRatio=6 каждый регион Survivor будет занимать одну восьмую размера всего младшего поколения, а Eden — шесть восьмых (помним про правило опций *Ratio).

C помощью опции -XX:-UseGCOverheadLimit можно отключить порог активности сборщика в 98%,
при достижении которого возникает OutOfMemoryError.
-XX:+PrintTenuringDistribution, которая добавляет статистику
по Survivor к выводу информации о некоторых сборках мусора.
2.
Параллельный сборщик включается опцией -XX:+UseParallelGC
Вы можете вручную указать количество потоков, которое хотели бы выделить для сборки мусора.
Это делается с помощью опции -XX:ParallelGCThreads=?. Например, -XX:ParallelGCThreads=9 ограничит
количество потоков девятью.
Parallel GC (параллельный сборщик) развивает идеи, заложенные последовательным сборщиком,
добавляя в них параллелизм и немного интеллекта. Если на вашем компьютере больше одного
 процессорного ядра и вы явно не указали, какой сборщик хотите использовать в своей программе,
 то почти наверняка JVM остановит свой выбор на Parallel GC. Он достаточно простой, но в то же время
достаточно функциональный, чтобы удовлетворить потребности большинства приложений
Бесспорным плюсом данного сборщика на фоне Serial GC является возможность
автоматической подстройки под требуемые параметры производительности и меньшие паузы на время
 cборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех
 приложениях.

Определенная фрагментация памяти, конечно, является минусом, но вряд ли она будет существенной для
большинства приложений, так как сборщиком используется относительно небольшое количество потоков.

В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для
большинства
приложений. У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

Но бывает так, что его оказывается недостаточно и нужно искать что-то более изощренное.

3.CMS GCрасшифровывается как Concurrent Mark Sweep) появился в HotSpot VM в одно время с
 Parallel GC в качестве его альтернативы для использования в приложениях, имеющих доступ к
нескольким ядрам процессора и чувствительных к паузам STW.
Использование CMS GC включается опцией -XX:+UseConcMarkSweepGC.

Достоинством данного сборщика по сравнению с рассмотренными ранее Serial / Parallel GC
является его ориентированность на минимизацию времен простоя, что является критическим фактором
 для многих приложений. Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.

Вспомним еще, что данный сборщик не уплотняет объекты в старшем поколении, что приводит
 к фрагментации Tenured. Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению (конкретно — старшему поколению) больше памяти, чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).

Ну и долгие паузы при потенциально возможных сбоях конкурентного режима могут стать
неприятным сюрпризом. Хотя они не частые, и при наличии достаточного объема памяти CMS’у удается их полностью избегать.

Тем не менее, такой сборщик может подойти приложениям, использующим большой объем долгоживущих данных.
4.G1 GC самый молодой сборщикВключается -XX:+UseG1GC.

Так как основной целью сборщика G1 является минимизация пауз в работе основного приложения,
то и главной опцией при его настройке можно считать уже встречавшуюся нам -XX:MaxGCPauseMillis=?, задающую приемлемое для нас максимальное время разовой сборки мусора. Даже если вы не собираетесь задавать это свойство, хотя бы проверьте его значение по умолчанию. Хотя в документации Oracle и говориться, что по умолчанию время сборки не ограничено, но по факту это не всегда так.

Опции -XX:ParallelGCThreads=? и -XX:ConcGCThreads=? задают количество потоков, которые будут использоваться для сборки мусора и для выполнения цикла пометок соответственно.

Если вас не устраивает автоматический выбор размера региона, вы можете задать его вручную с
помощью опции -XX:G1HeapRegionSize=?. Значение должно быть степенью двойки, если мерить в мегабайтах. Например, -XX:G1HeapRegionSize=16m.

При желании можно изменить порог заполненности кучи, при достижении которого инициируется
выполнение цикла пометок и переход в режим смешанных сборок. Это делается опцией -XX:InitiatingHeapOccupancyPercent=?, принимающей значение в процентах. По умолчанию, этот порог равен 45%.

Если же вы решите залезть в дебри настроек G1 по-глубже, то можете включить дополнительные
функции опциями -XX:+UnlockExperimentalVMOptions и -XX:+AggressiveOpts и поиграть с экспериментальными настройками.

Достоинства и недостатки

G1 DukeВ целом считается, что сборщик G1 более аккуратно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. При этом он лишен и некоторых других недостатков CMS, например, он не фрагментирует память.

Расплатой за достоинства G1 являются ресурсы процессора, которые он использует для выполнения достаточно большой части своей работы параллельно с основной программой. В результате страдает пропускная способность приложения. Целевым значением пропускной способности по умолчанию для G1 является 90%. Для Parallel GC, например, это значение равно 99%. Это, конечно, не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует всегда иметь в виду.


Вот мы и разобрали алгоритмы работы всех четырех сборщиков мусора в виртуальной машине HotSpot. В следующей статье попробуем разобраться, каким образом эти знания можно применять для оптимизации работы приложений.